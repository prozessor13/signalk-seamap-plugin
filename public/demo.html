<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Seamap Plugin - MapLibre GL Demo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src='/signalk-seamap-plugin/maplibre-gl.js'></script>
    <link rel='stylesheet' href='/signalk-seamap-plugin/maplibre-gl.css' />
    <style>
        body {
            margin: 0;
            padding: 0;
        }
        #map {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
        }
        .home-link {
            position: absolute;
            top: 10px;
            left: 10px;
            background: white;
            padding: 10px 15px;
            border-radius: 6px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            text-decoration: none;
            color: #9b59b6;
            font-size: 14px;
            font-weight: bold;
            z-index: 1000;
        }
        .home-link:hover {
            background: #f8f8f8;
        }

        /* Style Switcher */
        .style-switcher {
            position: absolute;
            top: 10px;
            right: 10px;
            background: white;
            border-radius: 6px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            display: flex;
            padding: 4px;
            gap: 4px;
        }

        .style-switcher button {
            padding: 8px 16px;
            border: none;
            background: transparent;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background 0.2s;
            font-family: sans-serif;
        }

        .style-switcher button:hover {
            background: #f0f0f0;
        }

        .style-switcher button.active {
            background: #9b59b6;
            color: white;
        }

        /* Bathymetry Switcher */
        .bathy-switcher {
            position: absolute;
            top: 52px;
            right: 10px;
            background: white;
            border-radius: 6px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            display: flex;
            padding: 4px;
            gap: 4px;
        }

        .bathy-switcher button {
            padding: 8px 16px;
            border: none;
            background: transparent;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background 0.2s;
            font-family: sans-serif;
        }

        .bathy-switcher button:hover {
            background: #f0f0f0;
        }

        .bathy-switcher button.active {
            background: #2980b9;
            color: white;
        }

        /* HUD Styles */
        .ui {
            position: absolute;
            inset: 0;
            pointer-events: none;
        }

        .panel {
            pointer-events: auto;
            background: #f7f7f7;
            border-radius: 10px;
            padding: 10px;
            display: flex;
            gap: 12px;
            justify-content: center;
            box-sizing: border-box;
            height: 120px;
            width: 510px;
        }

        .hud-wrapper {
            position: absolute;
            left: 50%;
            bottom: 10px;
            transform: translateX(-50%);
        }

        .card {
            background: #fefefe;
            border-radius: 10px;
            padding: 14px 12px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            align-items: center;
            text-align: center;
            width: 88px;
            flex: 0 0 auto;
        }

        .label {
            font-size: 12px;
            color: #e86a28;
            font-weight: 300;
            letter-spacing: .04em;
            font-family: sans-serif;
            opacity: .7;
        }

        .value {
            font-size: 30px;
            color: hsl(20,61%,14%);
            font-weight: 100;
            font-family: sans-serif;
            line-height: 1;
        }

        .value-pos {
            font-size: 14px;
            color: hsl(20,61%,14%);
            font-weight: 100;
            font-family: sans-serif;
            line-height: 1.8;
        }

        .sub {
            font-size: 12px;
            color: #e86a28;
            font-weight: 300;
            font-family: sans-serif;
            opacity: .7;
        }

        @media (min-width: 1101px) {
            .hud-wrapper {
                left: 10px;
                top: auto;
                bottom: 10px;
                transform: none;
            }
        }

        @media (max-width: 520px) {
            .hud-wrapper .panel {
                transform: scale(0.8);
                transform-origin: bottom center;
            }
        }

        /* Tooltip Styles */
        .seamark-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 10px 12px;
            border-radius: 6px;
            font-family: monospace;
            font-size: 12px;
            pointer-events: none;
            z-index: 10000;
            max-width: 400px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            line-height: 1.5;
            user-select: none;
        }

        .seamark-tooltip.pinned {
            pointer-events: auto;
            user-select: text;
        }

        .seamark-tooltip .tooltip-key {
            color: #90cdf4;
            font-weight: bold;
        }

        .seamark-tooltip .tooltip-value {
            color: #fbd38d;
        }

        .seamark-tooltip .tooltip-title {
            color: #9ae6b4;
            font-weight: bold;
            margin-bottom: 6px;
            padding-bottom: 4px;
            border-bottom: 1px solid rgba(255,255,255,0.2);
        }
    </style>
</head>
<body>
    <a href="./" class="home-link">← Back to Downloader</a>
    <div class="style-switcher">
        <button id="style-seamap" class="active">Seamap</button>
        <button id="style-slim">Slim</button>
    </div>
    <div class="bathy-switcher">
        <button id="bathy-gebco" class="">GEBCO</button>
        <button id="bathy-emod" class="">EMODnet</button>
    </div>
    <div id="map"></div>

    <!-- HUD Overlay -->
    <div class="ui">
        <div class="hud-wrapper">
            <section class="panel hud" aria-label="HUD">
                <div class="card">
                    <div class="label">Heading</div>
                    <div class="value" id="hud-heading">–</div>
                    <div class="sub">True</div>
                </div>
                <div class="card">
                    <div class="label">Position</div>
                    <div class="value-pos" id="hud-position">–</div>
                </div>
                <div class="card">
                    <div class="label">SOG</div>
                    <div class="value" id="hud-sog">–</div>
                    <div class="sub">Knots</div>
                </div>
                <div class="card">
                    <div class="label">Depth</div>
                    <div class="value" id="hud-depth">–</div>
                    <div class="sub">Meters</div>
                </div>
            </section>
        </div>
    </div>

    <script>
        // SignalK configuration
        const SIGNALK = { ws: null };

        // Helper functions
        const rad2deg = r => (r * 180 / Math.PI + 360) % 360;
        const ms2kn = m => m * 1.9438444924574;
        const fmtNum = (n, d = 2) => (Number.isFinite(n) ? n.toFixed(d) : '–');
        const fmtLat = lat => {
            const h = lat >= 0 ? 'N' : 'S', a = Math.abs(lat), d = Math.floor(a);
            let m = (a - d) * 60;
            m = Math.round(m * 1e3) / 1e3;
            if (m >= 60) { m = 0; }
            return `${h} ${d}°${m.toFixed(3)}′`;
        };
        const fmtLng = lng => {
            const h = lng >= 0 ? 'E' : 'W', a = Math.abs(lng), d = Math.floor(a);
            let m = (a - d) * 60;
            m = Math.round(m * 1e3) / 1e3;
            if (m >= 60) { m = 0; }
            return `${h} ${d}°${m.toFixed(3)}′`;
        };

        // Get query parameters
        const urlParams = new URLSearchParams(window.location.search);
        const bathymetry = urlParams.get('bathymetry') || 'gebco';

        // Bathymetry switcher - highlight active button
        document.getElementById(`bathy-${bathymetry === 'emod' ? 'emod' : 'gebco'}`).classList.add('active');

        document.getElementById('bathy-gebco').addEventListener('click', () => switchBathymetry('gebco'));
        document.getElementById('bathy-emod').addEventListener('click', () => switchBathymetry('emod'));

        function switchBathymetry(value) {
            const params = new URLSearchParams(window.location.search);
            params.set('bathymetry', value);
            window.location.search = params.toString();
        }

        // Build style URL with query parameters
        let styleUrl = '/plugins/signalk-seamap-plugin/styles/seamap.json?base_url=' + window.location.origin;
        if (bathymetry) {
            styleUrl += '&bathymetry=' + encodeURIComponent(bathymetry);
        }

        // Initialize map with plugin stylesheet
        const map = new maplibregl.Map({
            container: 'map',
            hash: true,
            center: [6.3, 46.2],
            zoom: 4,
            minZoom: 4,
            style: styleUrl,
            fillLargeMeshArrays: true
        });

        // Add controls
        map.addControl(new maplibregl.NavigationControl(), 'bottom-right');
        map.addControl(new maplibregl.ScaleControl(), 'bottom-left');

        // Boat icon SVG
        const boatSvg = `<?xml version="1.0" encoding="UTF-8"?><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
          <polygon points="50,5 90,95 50,80 10,95" fill="#1f6feb" stroke="#fff" stroke-width="4" stroke-linejoin="round"/>
        </svg>`;
        const boatImg = new Image(64, 64);
        boatImg.onload = () => map.addImage('boat', boatImg, { pixelRatio: 2 });
        boatImg.src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(boatSvg);

        // SignalK data
        const last = { lat: null, lng: null, hdg: null, sog: null, depth: null };

        // Error handling
        map.on('error', (e) => {
            console.error('Map error:', e);
        });

        map.on('load', () => {
            console.log('Map loaded successfully');

            // Setup style switcher
            setupStyleSwitcher();

            // Setup seamark tooltip
            setupSeamarkTooltip();

            // Add vessel source and layer
            map.addSource('vessel', {
                type: 'geojson',
                data: { type: 'FeatureCollection', features: [] }
            });

            map.addLayer({
                id: 'vessel-layer',
                type: 'symbol',
                source: 'vessel',
                layout: {
                    'icon-image': 'boat',
                    'icon-size': 0.6,
                    'icon-allow-overlap': true,
                    'icon-rotate': ['get', 'heading'],
                    'icon-rotation-alignment': 'map',
                }
            });

            // Add heading line source and layer
            map.addSource('heading-line', {
                type: 'geojson',
                data: { type: 'FeatureCollection', features: [] }
            });

            map.addLayer({
                id: 'heading-line-layer',
                type: 'line',
                source: 'heading-line',
                paint: {
                    'line-width': 3,
                    'line-color': '#1f6feb',
                    'line-opacity': 0.8
                }
            });

            // Connect to SignalK
            connectWS();
        });

        // WebSocket connection
        function connectWS() {
            try {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                SIGNALK.ws = new WebSocket(`${protocol}//${window.location.host}/signalk/v1/stream?subscribe=self`);
                SIGNALK.ws.onmessage = (ev) => handleDelta(JSON.parse(ev.data));
                SIGNALK.ws.onerror = () => SIGNALK.ws.close();
                SIGNALK.ws.onclose = () => setTimeout(() => connectWS(), 5000);
            } catch (e) {
                setTimeout(() => connectWS(), 1000);
            }
        }

        // Handle SignalK delta
        function handleDelta(delta) {
            if (!delta || !delta.updates) return;
            for (const up of delta.updates) {
                const ts = up.timestamp;
                for (const v of (up.values || [])) {
                    const p = v.path || '';
                    const val = v.value;
                    if (p === 'navigation.position') {
                        applyUpdate(val?.latitude, val?.longitude, last.hdg, last.sog, last.depth, ts);
                    } else if (p === 'navigation.headingTrue' || p === 'navigation.courseOverGroundTrue') {
                        applyUpdate(last.lat, last.lng, val, last.sog, last.depth, ts);
                    } else if (p === 'navigation.speedOverGround') {
                        applyUpdate(last.lat, last.lng, last.hdg, val, last.depth, ts);
                    } else if (p.startsWith('environment.depth.')) {
                        applyUpdate(last.lat, last.lng, last.hdg, last.sog, val, ts);
                    }
                }
            }
        }

        // Apply updates
        function applyUpdate(lat, lng, hdg, sog, depth, ts) {
            if (Number.isFinite(lat)) last.lat = lat;
            if (Number.isFinite(lng)) last.lng = lng;
            if (Number.isFinite(hdg)) last.hdg = hdg;
            if (Number.isFinite(sog)) last.sog = sog;
            if (Number.isFinite(depth)) last.depth = depth;
            updateHud();
            updateMap();
        }

        // Update HUD display
        function updateHud() {
            document.getElementById('hud-heading').textContent = Number.isFinite(last.hdg) ? `${fmtNum(rad2deg(last.hdg), 0)}°` : '–';
            document.getElementById('hud-position').innerHTML = (last.lat != null && last.lng != null) ? `${fmtLat(last.lat)}<br>${fmtLng(last.lng)}` : '–';
            document.getElementById('hud-sog').textContent = Number.isFinite(last.sog) ? fmtNum(ms2kn(last.sog), 1) : '–';
            document.getElementById('hud-depth').textContent = Number.isFinite(last.depth) ? fmtNum(last.depth, 1) : '–';
        }

        // Update map with vessel position and heading line
        function updateMap() {
            if (!last.lat || !last.lng || !map.getSource('vessel')) return;

            const headingDeg = Number.isFinite(last.hdg) ? rad2deg(last.hdg) : 0;

            // Update vessel position
            map.getSource('vessel').setData({
                type: 'FeatureCollection',
                features: [{
                    type: 'Feature',
                    geometry: { type: 'Point', coordinates: [last.lng, last.lat] },
                    properties: { heading: headingDeg }
                }]
            });

            // Update heading line (only if moving)
            if (Number.isFinite(last.sog) && last.sog > 0.1 && Number.isFinite(last.hdg)) {
                const lineLength = 0.01; // Length in degrees
                const headingRad = last.hdg;
                const endLat = last.lat + (lineLength * Math.cos(headingRad));
                const endLng = last.lng + (lineLength * Math.sin(headingRad) / Math.cos(last.lat * Math.PI / 180));

                map.getSource('heading-line').setData({
                    type: 'FeatureCollection',
                    features: [{
                        type: 'Feature',
                        geometry: {
                            type: 'LineString',
                            coordinates: [[last.lng, last.lat], [endLng, endLat]]
                        }
                    }]
                });
            } else {
                // Clear heading line if not moving
                map.getSource('heading-line').setData({
                    type: 'FeatureCollection',
                    features: []
                });
            }

            // Center map on vessel on first position update
            if (!map.userInteracted) {
                map.setCenter([last.lng, last.lat]);
                map.setZoom(12);
            }
        }

        // Track user interaction to prevent auto-centering
        map.on('movestart', (e) => {
            if (e.originalEvent) {
                map.userInteracted = true;
            }
        });

        // Style switcher functionality
        function setupStyleSwitcher() {
            document.getElementById('style-seamap').addEventListener('click', () => {
                switchStyle('seamap');
            });

            document.getElementById('style-slim').addEventListener('click', () => {
                switchStyle('slim');
            });
        }

        function switchStyle(styleName) {
            let styleUrl = `/plugins/signalk-seamap-plugin/styles/${styleName}.json?base_url=${window.location.origin}`;
            if (bathymetry) {
                styleUrl += '&bathymetry=' + encodeURIComponent(bathymetry);
            }

            map.setStyle(styleUrl);

            // Update active button
            document.querySelectorAll('.style-switcher button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(`style-${styleName}`).classList.add('active');

            // Re-add vessel layers after style loads
            map.once('styledata', () => {
                // Re-add boat image
                const boatImg2 = new Image(64, 64);
                boatImg2.onload = () => {
                    if (!map.hasImage('boat')) {
                        map.addImage('boat', boatImg2, { pixelRatio: 2 });
                    }

                    // Re-add vessel source and layers
                    if (!map.getSource('vessel')) {
                        map.addSource('vessel', {
                            type: 'geojson',
                            data: { type: 'FeatureCollection', features: [] }
                        });

                        map.addLayer({
                            id: 'vessel-layer',
                            type: 'symbol',
                            source: 'vessel',
                            layout: {
                                'icon-image': 'boat',
                                'icon-size': 0.6,
                                'icon-allow-overlap': true,
                                'icon-rotate': ['get', 'heading'],
                                'icon-rotation-alignment': 'map',
                            }
                        });
                    }

                    if (!map.getSource('heading-line')) {
                        map.addSource('heading-line', {
                            type: 'geojson',
                            data: { type: 'FeatureCollection', features: [] }
                        });

                        map.addLayer({
                            id: 'heading-line-layer',
                            type: 'line',
                            source: 'heading-line',
                            paint: {
                                'line-width': 3,
                                'line-color': '#1f6feb',
                                'line-opacity': 0.8
                            }
                        });
                    }

                    // Update map with current position
                    updateMap();
                };
                boatImg2.src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(boatSvg);
            });
        }

        // Seamark tooltip functionality
        let tooltip = null;
        let tooltipPinned = false;

        function setupSeamarkTooltip() {
            // Create tooltip element
            tooltip = document.createElement('div');
            tooltip.className = 'seamark-tooltip';
            tooltip.style.display = 'none';
            document.body.appendChild(tooltip);

            // Track mouse position over the map
            map.on('mousemove', (e) => {
                // Don't update tooltip on hover if it's pinned
                if (tooltipPinned) {
                    map.getCanvas().style.cursor = '';
                    return;
                }

                const features = map.queryRenderedFeatures(e.point);

                // Filter for seamark features (source-layer === 'seamark')
                const seamarkFeatures = features.filter(f => {
                    return f.sourceLayer === 'seamark';
                });

                if (seamarkFeatures.length > 0) {
                    // Show tooltip for first seamark feature
                    const feature = seamarkFeatures[0];
                    showTooltip(e, feature);
                    map.getCanvas().style.cursor = 'pointer';
                } else {
                    hideTooltip();
                    map.getCanvas().style.cursor = '';
                }
            });

            // Click on seamark to pin tooltip
            map.on('click', (e) => {
                const features = map.queryRenderedFeatures(e.point);

                // Filter for seamark features (source-layer === 'seamark')
                const seamarkFeatures = features.filter(f => {
                    return f.sourceLayer === 'seamark';
                });

                if (seamarkFeatures.length > 0) {
                    // Pin tooltip on seamark
                    const feature = seamarkFeatures[0];
                    showTooltip(e, feature);
                    tooltipPinned = true;
                    tooltip.classList.add('pinned');
                } else {
                    // Unpin and hide tooltip on map click
                    tooltipPinned = false;
                    tooltip.classList.remove('pinned');
                    hideTooltip();
                }
            });

            // Hide tooltip when mouse leaves the map (only if not pinned)
            map.on('mouseleave', () => {
                if (!tooltipPinned) {
                    hideTooltip();
                }
            });
        }

        function showTooltip(e, feature) {
            if (!tooltip) return;

            // Build tooltip content
            let content = '<div class="tooltip-title">Seamark Properties</div>';

            // Sort properties alphabetically
            const props = Object.keys(feature.properties).sort();

            for (const key of props) {
                const value = feature.properties[key];
                // Skip internal MapLibre properties and null/undefined values
                if (key.startsWith('$') || value === null || value === undefined) continue;

                content += `<div><span class="tooltip-key">${escapeHtml(key)}:</span> <span class="tooltip-value">${escapeHtml(String(value))}</span></div>`;
            }

            tooltip.innerHTML = content;
            tooltip.style.display = 'block';

            // Position tooltip near cursor
            const x = e.point.x + 15;
            const y = e.point.y + 15;

            tooltip.style.left = `${x}px`;
            tooltip.style.top = `${y}px`;

            // Adjust if tooltip goes off screen
            const rect = tooltip.getBoundingClientRect();
            if (rect.right > window.innerWidth) {
                tooltip.style.left = `${x - rect.width - 30}px`;
            }
            if (rect.bottom > window.innerHeight) {
                tooltip.style.top = `${y - rect.height - 30}px`;
            }
        }

        function hideTooltip() {
            if (tooltip) {
                tooltip.style.display = 'none';
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
    </script>
</body>
</html>
